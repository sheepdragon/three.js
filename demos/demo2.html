<!DOCTYPE html>
<html lang="en">
	<head>
		<title>demo</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
		/>
		<link type="text/css" rel="stylesheet" href="/examples/main.css" />
		<style>
			a {
				color: blue;
			}
			.control-inactive button {
				color: #888;
			}
		</style>
	</head>
	<body>
		<div id="container"></div>
		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script
			async
			src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
		></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "/examples/jsm/"
				}
			}
		</script>

		<script type="module">
			import * as THREE from "three";

			import Stats from "three/addons/libs/stats.module.js";
			import { GUI } from "three/addons/libs/lil-gui.module.min.js";
			import { OrbitControls } from "three/addons/controls/OrbitControls.js";
			import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

			let scene, renderer, camera, stats, clock;
			let controls, mesh;

			init();
			animate();

			function init() {
				clock = new THREE.Clock();
				const container = document.getElementById("container");

				stats = new Stats();
				container.appendChild(stats.dom);

				// renderer
				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				// renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.shadowMap.enabled = true;
				container.appendChild(renderer.domElement);

				scene = new THREE.Scene();
				scene.background = new THREE.Color(0xf0f0f0);
				// scene.fog = new THREE.Fog(0xa0a0a0, 10, 50);
				scene.add(new THREE.AxesHelper(30));

				// camera
				camera = new THREE.PerspectiveCamera(
					40,
					window.innerWidth / window.innerHeight,
					1,
					1000
				);
				camera.position.set(15, 17, 40);
				window.camera = camera

				// controls
				controls = new OrbitControls(camera, renderer.domElement);
				controls.target.set(0, 1, 0);
				controls.update();
				controls.enablePan = true;
				controls.enableZoom = true;
				controls.enableDamping = true;

				// 光源
				const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
				hemiLight.position.set(0, 50, 0);
				scene.add(hemiLight);
				scene.add(new THREE.HemisphereLightHelper(hemiLight, 5));

				const light = new THREE.SpotLight(0xffffff, 1.5);
				light.position.set(50, 50, -10);
				light.angle = Math.PI * 0.2;
				light.castShadow = true;
				scene.add(light);
				scene.add(new THREE.SpotLightHelper(light));

				// ground
				const groundMesh = new THREE.Mesh(
					new THREE.PlaneGeometry(200, 200),
					new THREE.ShadowMaterial({ color: 0x000000, opacity: 0.2 })
				);
				groundMesh.rotation.x = -Math.PI / 2;
				groundMesh.receiveShadow = true;
				scene.add(groundMesh);

				const helper = new THREE.GridHelper(200, 50);
				helper.position.y = -0;
				helper.material.opacity = 0.5;
				helper.material.transparent = true;
				scene.add(helper);

				// box
				const loader = new THREE.TextureLoader();

				const boxGeometry = new THREE.BoxGeometry(10, 10, 10);
				const dodecahedronGeometry = new THREE.DodecahedronGeometry(10, 0)

				const geometry = boxGeometry
				const material = new THREE.MeshPhongMaterial({
					map: loader.load("./texture-atlas.jpg"),
				});
				window.t = { geometry, material };

				mesh = new THREE.Mesh(geometry, material);
				mesh.position.y = 5;
				mesh.castShadow = true;
				scene.add(mesh);

				const uvAttribute = geometry.getAttribute("uv");
				for (let i = 0; i < uvAttribute.count; i++) {
					const x = uvAttribute.getX(i);
					const y = uvAttribute.getY(i);
					console.log("==", i, x, y);
					// uvAttribute.setXY(i, x/2, y/3)
				}

				// 24 / 4 = 6
				// z 字型顺序
				uvAttribute.setXY(0, 0, 1/3)
				uvAttribute.setXY(1, 1/2, 1/3)
				uvAttribute.setXY(2, 0, 0)
				uvAttribute.setXY(3, 1/2, 0)

				uvAttribute.setXY(4, 1/2, 1/3)
				uvAttribute.setXY(5, 1, 1/3)
				uvAttribute.setXY(6, 1/2, 0)
				uvAttribute.setXY(7, 1, 0)

				uvAttribute.setXY(8, 0, 2/3)
				uvAttribute.setXY(9, 1/2, 2/3)
				uvAttribute.setXY(10, 0, 1/3)
				uvAttribute.setXY(11, 1/2, 1/3)

				uvAttribute.setXY(12, 1/2, 2/3)
				uvAttribute.setXY(13, 1, 2/3)
				uvAttribute.setXY(14, 1/2, 1/3)
				uvAttribute.setXY(15, 1, 1/3)

				uvAttribute.setXY(16, 0, 1)
				uvAttribute.setXY(17, 1/2, 1)
				uvAttribute.setXY(18, 0, 2/3)
				uvAttribute.setXY(19, 1/2, 2/3)

				uvAttribute.setXY(20, 1/2, 1)
				uvAttribute.setXY(21, 1, 1)
				uvAttribute.setXY(22, 1/2, 2/3)
				uvAttribute.setXY(23, 1, 2/3)

			}

			window.onresize = function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			};

			function animate() {
				requestAnimationFrame(animate);

				controls.update();
				stats.update();
				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>
